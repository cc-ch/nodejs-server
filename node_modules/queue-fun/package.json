{
  "name": "queue-fun",
  "version": "0.2.4",
  "description": "基于Promise的 运行队列控制类",
  "homepage": "https://github.com/cnwhy/queue-fun",
  "main": "index.js",
  "files": [
    "index.js",
    "queue-fun.min.js",
    "lib/*",
    "demo/*"
  ],
  "scripts": {
    "test": "mocha --bail --reporter spec test/mocha_*.js",
    "test-cov": "istanbul cover node_modules/mocha/bin/_mocha -- --reporter dot test/mocha_*.js",
    "test-travis": "istanbul cover node_modules/mocha/bin/_mocha --report lcovonly -- --reporter spec test/mocha_*.js",
    "test-grunt": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/cnwhy/queue-fun.git"
  },
  "keywords": [
    "queue",
    "Promise",
    "Async",
    "Q",
    "队列"
  ],
  "dependencies": {},
  "devDependencies": {
    "express": "^4.12.3",
    "grunt": "^0.4.5",
    "grunt-browserify": "^3.8.0",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-contrib-uglify": "^0.9.1",
    "grunt-mocha-istanbul": "^2.4.0",
    "grunt-mocha-test": "^0.12.7",
    "istanbul": "0.3.15",
    "q": "*",
    "bluebird": "*"
  },
  "author": {
    "name": "cnwhy",
    "email": "w.why@163.com"
  },
  "license": "BSD",
  "readme": "# queue-fun\n[![NPM version][npm-image]][npm-url]\n[![npm download][download-image]][npm-url]\n[![Test coverage][coveralls-image]][coveralls-url]\n[![Build Status][BuildStatus-image]][BuildStatus-url]\n\n[npm-image]: https://img.shields.io/npm/v/queue-fun.svg\n[download-image]: https://img.shields.io/npm/dm/queue-fun.svg\n[npm-url]: https://npmjs.org/package/queue-fun\n[coveralls-image]: https://coveralls.io/repos/cnwhy/queue-fun/badge.svg?branch=master\n[coveralls-url]: https://coveralls.io/r/cnwhy/queue-fun?branch=master\n[BuildStatus-url]: https://travis-ci.org/cnwhy/queue-fun\n[BuildStatus-image]: https://travis-ci.org/cnwhy/queue-fun.svg\nqueue-fun 是基于Promise的 运行队列控制类。\n\n## 使用场景\n- 巨量同逻辑业务平稳处理\n- 间歇性高并发系统\n- 控制单用户占用资源过高\n\n**一点建议** \n>并不需要把整个业务的后续处理全都放到队列中去，而只是将高消耗的那一部分放入队列，利用Promise的异部处理机制来处理后续的操作。  \n>如果已经在用Promise来控制异步流程,我相信这是一个非高好用的队列,因为你在在编写代码的时候几乎可以忘记队列的存在，但是他就在那里默默的工作着，代码可读性和灵活性也没有丝毫影响。\n\n[github-q]: https://github.com/kriskowal/q\n### 队列  \n##### queue-fun.Queue(*q*) \n初始化队类 参数**q**可传: \n- **无参数** 队列使用内置实现的Promise;  \n- 传入 **[q][github-q] / 原生Promise** (插入队列方法: `push` `unshift` `go` `jump`返回对应的promise实例) , 其实现了`defer`,`then`类似promise的类都可以.  \n\n```javascript\n//使用内置实现的Promise\nvar Queue = new queue-fun.Queue() //promise实现和模仿了q的API,但比q要快 除了then, \"done, spread, fail, fin\"都是支持的 \n\n//Queue1使用q做为队列使用的promise实现\nvar Queue1 = new queue-fun.Queue(require(\"q\"));\n//Queue2使用原生Promise做为队列使用的promise实现\nvar Queue2 = new queue-fun.Queue(Promise);\n```\n\n##### 实例化队列 new queue-fun.Queue()(runMax, *con*) \n- runMax 并行运行队列方法的最大个数\n- con 配置队列 **开始 结束** 事件,运行单元的 **成功,失败** 事件及配置执行单元出错的 **重试** 机制。[详细配置方法](https://github.com/cnwhy/queue-fun/wiki/%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%98%9F%E5%88%97%E9%85%8D%E7%BD%AE%22%E8%B6%85%E6%97%B6%22,%22%E9%87%8D%E8%AF%95%22%E7%AD%89%E5%8F%82%E6%95%B0)  \n```javascript\nvar queue = new Queue(100)\n```\n\n#### API  \n##### queue.push(promisefun, *args[]*, *con*)  \n向队列中尾部添加运行单元，返回promise  \n- promisefun: promise function\n- args: 传入的参数\n- con [默认值](https://github.com/cnwhy/queue-fun/wiki/%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E)  \n\n##### queue.unshift(promisefun, *args[]*, *con*) 同push 向队列中头部添加运行单元  \n##### queue.go(promisefun, *args[]*, *con*)  同push,添加后会启动队列.  \n##### queue.jump(promisefun, *args[]*, *con*) 同unshift,添加后启动队列.  \n\n#### 批量添加\n以下方法可以向队列添加一组运行单元，返回的promise对像，状态规则如下：\n- 所有单元执行完前，且没有执行单元状态为rejected，其状态一直为pending\n- 所有单元的promise状态都为fulfilled时，状态才为fulfilled，值为各执行单元值组成的数组或对像。\n- 运行单元的promise有rejected时，其状态立即为rejected，理由同最先变为rejected的值行单元的理由。  \n\n##### queue.all(arr,*start*,*jump*)\n添加一批执行单元。\n- `arr` 元素同queue.push方法 `[[promisefun,args,con], [promisefun,args,con]]`\n- `start` 添加完后是否立即运行队列 默认 false\n- `jump` 是否优先执行 默认 false  \n\n##### queue.allLike/allArray (arrArgs[],promisefun,*con*,*start*,*jump*)  \n向队列添加同一批同逻辑的运行单元.\n- `arrArgs[]` array 参数数组,多个参数请嵌套数组 `[1,2,[3,3.1],4]`\n- `promisefun`  \n\n返回值为promise对像或类promise对像的方法，普通函数将转变以函数值为值的promise对像\n- `con` 参看*queue.push* 可以省略\n- `start` 添加完后是否立即运行队列 默认 false\n- `jump` 是否优先执行 默认 false  \n\n##### queue.allEach(arr/map,promisefun,*con*,*start*,*jump*)  \n第一个参数可以是数组，也可以是一个map对像。  \n类似allLike，只是向promisefun传参类似forEach传参 (element, index, arrArgs)  \n\n##### queue.allMap(map,promisefun,*con*,*start*,*jump*)  \n第一个参数可以是数组，也可以是一个map对像。  \n类似allLike，只是向promisefun传参类似forEach传参 (element, index, arrArgs)  \n注意：返回的promise，的值将也是一个map对像\n  \n#### 队列控制\n##### queue.setMax(newMax)  \n修改并行数  \n\n##### queue.start()  \n启动队列  \n\n##### queue.stop()  \n暂停队列  \n\n##### queue.clear(err)  \n清空队列,队列中剩余的项都将以err为理由拒绝。  \n\n### demo\n``` javascript\nvar queuefun = require('queue-fun');\nvar Queue = queuefun.Queue(); //初始化Promise异步队列类\nvar q = queuefun.Q;  //配合使用的Promise流程控制类，也可以使用q.js代替\n\n//实列化一个最大并发为1的队列\nvar queue1 = new Queue(1); \n\n//定义一个Promise风格的异步方法\nfunction testfun(i){\n\tvar deferred = q.defer();\n\tsetTimeout(function(){\n\t\tdeferred.resolve(i)\n\t},300)\n\treturn deferred.promise;\n}\nvar log = function(a){ console.log(a); }\n//向队列添加运行单元\nqueue1.push(testfun,[1]).then(console.log); \n//插入普通方法会按Promises/A+规则反回promise\nqueue1.push(function(){return 2;}).then(console.log);\n//插入优先执行项 (后进先出)\nqueue1.unshift(testfun,[0]).then(console.log);\n//批量插入多个远行项 array\nqueue1.allArray([3,4],testfun,{'event_succ':log}).then(console.log) \n//批量插入多个远行项 map \nqueue1.allMap({'a':5,'b':6,'c':7},testfun,{'event_succ':log}).then(console.log)\n//执行队列\nqueue1.start();\n\n/*\n0\n1\n2\n3\n4\n[ 3, 4 ]\n5\n6\n7\n{ a: 5, b: 6, c: 7 }\n*/\n```\n\n## 关于内置Promise实现类queuefun.Q\n实现了Promises/A+规范及`done`,`spread`,`fail`,`fin`;  \nAPI模仿[Q](https://github.com/kriskowal/q);  \n模拟实现了 `q.defer`,`q.Promise`,`q.all`,`q.any`,`q.nfcall`,`q.nfapply`,`q.denodeify`,`q.delay` 等函数.\n更详细的说明参看 [q模块][github-q]\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/cnwhy/queue-fun/issues"
  },
  "_id": "queue-fun@0.2.4",
  "_from": "queue-fun@"
}
